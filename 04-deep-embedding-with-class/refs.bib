@misc{bolingbroke_constraint_2011,
	title = {Constraint {Kinds} for {GHC}},
	url = {http://blog.omega-prime.co.uk/2011/09/10/constraint-kinds-for-ghc/},
	journal = {:: (Bloggable a) ={\textgreater} a -{\textgreater} IO ()},
	author = {Bolingbroke, Max},
	month = sep,
	year = {2011},
	note = {blog post, accessed-on: 2021-06-09},
	file = {Constraint Kinds for GHC:/home/mrl/.local/share/zotero/storage/R6RL79K7/constraint-kinds-for-ghc.html:text/html},
}

@inproceedings{fegaras_revisiting_1996,
	address = {New York, NY, USA},
	series = {{POPL} '96},
	title = {Revisiting {Catamorphisms} over {Datatypes} with {Embedded} {Functions} (or, {Programs} from {Outer} {Space})},
	isbn = {0-89791-769-3},
	doi = {10.1145/237721.237792},
	abstract = {We revisit the work of Paterson and of Meijer \& Hutton, which describes how to construct catamorphisms for recursive datatype definitions that embed contravariant occurrences of the type being defined. Their construction requires, for each catamorphism, the definition of an anamorphism that has an inverse-like relationship to that catamorphism. We present an alternative construction, which replaces the stringent requirement that an inverse anamorphism be defined for each catamorphism with a more lenient restriction. The resulting construction has a more efficient implementation than that of Paterson, Meijer, and Hutton and the relevant restriction can be enforced by a Hindley-Milner type inference algorithm. We provide numerous examples illustrating our method.},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Fegaras, Leonidas and Sheard, Tim},
	year = {1996},
	note = {event-place: St. Petersburg Beach, FL, USA},
	pages = {284--294},
	file = {Fegaras and Sheard - 1996 - Revisiting Catamorphisms over Datatypes with Embed.pdf:/home/mrl/.local/share/zotero/storage/WCSRVWGC/Fegaras and Sheard - 1996 - Revisiting Catamorphisms over Datatypes with Embed.pdf:application/pdf},
}

@inproceedings{pfenning_higher-order_1988,
	address = {New York, NY, USA},
	series = {{PLDI} '88},
	title = {Higher-{Order} {Abstract} {Syntax}},
	isbn = {0-89791-269-1},
	doi = {10.1145/53990.54010},
	abstract = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1988 {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Pfenning, F. and Elliott, C.},
	year = {1988},
	note = {event-place: Atlanta, GA, USA},
	pages = {199--208},
	file = {Pfenning and Elliott - 1988 - Higher-Order Abstract Syntax.pdf:/home/mrl/.local/share/zotero/storage/2HSRWURK/Pfenning and Elliott - 1988 - Higher-Order Abstract Syntax.pdf:application/pdf},
}

@inproceedings{chlipala_parametric_2008,
	address = {New York, NY, USA},
	series = {{ICFP} '08},
	title = {Parametric {Higher}-{Order} {Abstract} {Syntax} for {Mechanized} {Semantics}},
	isbn = {978-1-59593-919-7},
	doi = {10.1145/1411204.1411226},
	abstract = {We present parametric higher-order abstract syntax (PHOAS), a new approach to formalizing the syntax of programming languages in computer proof assistants based on type theory. Like higher-order abstract syntax (HOAS), PHOAS uses the meta language's binding constructs to represent the object language's binding constructs. Unlike HOAS, PHOAS types are definable in general-purpose type theories that support traditional functional programming, like Coq's Calculus of Inductive Constructions. We walk through how Coq can be used to develop certified, executable program transformations over several statically-typed functional programming languages formalized with PHOAS; that is, each transformation has a machine-checked proof of type preservation and semantic preservation. Our examples include CPS translation and closure conversion for simply-typed lambda calculus, CPS translation for System F, and translation from a language with ML-style pattern matching to a simpler language with no variable-arity binding constructs. By avoiding the syntactic hassle associated with first-order representation techniques, we achieve a very high degree of proof automation.},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Chlipala, Adam},
	year = {2008},
	note = {event-place: Victoria, BC, Canada},
	keywords = {compiler verification, dependent types, interactive proof assistants, type-theoretic semantics},
	pages = {143--156},
	file = {Chlipala - 2008 - Parametric Higher-Order Abstract Syntax for Mechan.pdf:/home/mrl/.local/share/zotero/storage/DZ33DAMU/Chlipala - 2008 - Parametric Higher-Order Abstract Syntax for Mechan.pdf:application/pdf},
}

@incollection{reynolds_user-defined_1978,
	address = {New York, NY},
	title = {User-{Defined} {Types} and {Procedural} {Data} {Structures} as {Complementary} {Approaches} to {Data} {Abstraction}},
	isbn = {978-1-4612-6315-9},
	abstract = {User-defined types (or modes) and procedural (or functional) data structures are complementary methods for data abstraction, each providing a capability lacked by the other. With user-defined types, all information about the representation of a particular kind of data is centralized in a type definition and hidden from the rest of the program. With procedural data structures, each part of the program which creates data can specify its own representation, independently of any representations used elsewhere for the same kind of data. However, this decentralization of the description of data is achieved at the cost of prohibiting primitive operations from accessing the representations of more than one data item. The contrast between these approaches is illustrated by a simple example.},
	booktitle = {Programming {Methodology}: {A} {Collection} of {Articles} by {Members} of {IFIP} {WG2}.3},
	publisher = {Springer New York},
	author = {Reynolds, John C.},
	editor = {Gries, David},
	year = {1978},
	doi = {10.1007/978-1-4612-6315-9\_22},
	pages = {309--317},
	file = {Reynolds - 1978 - User-Defined Types and Procedural Data Structures .pdf:/home/mrl/.local/share/zotero/storage/ASXE73U2/Reynolds - 1978 - User-Defined Types and Procedural Data Structures .pdf:application/pdf},
}

@misc{ghc_team_ghc_2021,
	title = {{GHC} {User}’s {Guide} {Documentation}},
	url = {https://downloads.haskell.org/~ghc/latest/docs/users_guide.pdf},
	language = {English},
	urldate = {2021-02-24},
	publisher = {Release},
	author = {GHC Team},
	year = {2021},
	note = {Accessed on: 2021-02-24},
}

@misc{ghc_team_datadynamic_2021,
	title = {Data.{Dynamic}},
	url = {https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Dynamic.html},
	language = {English},
	urldate = {2021-02-24},
	publisher = {Release},
	author = {GHC Team},
	year = {2021},
	note = {Accessed on: 2021-02-24},
}

@inproceedings{jeuring_polytypic_1996,
	address = {Berlin, Heidelberg},
	title = {Polytypic programming},
	isbn = {978-3-540-70639-7},
	abstract = {Many functions have to be written over and over again for different datatypes, either because datatypes change during the development of programs, or because functions with similar functionality are needed on different datatypes. Examples of such functions are pretty printers, debuggers, equality functions, unifiers, pattern matchers, rewriting functions, etc. Such functions are called polytypic functions. A polytypic function is a function that is defined by induction on the structure of user-defined datatypes. This paper introduces polytypic functions, and shows how to construct and reason about polytypic functions. A larger example is studied in detail: polytypic functions for term rewriting and for determining whether a collection of rewrite rules is normalising.},
	booktitle = {Advanced {Functional} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Jeuring, Johan and Jansson, Patrik},
	editor = {Launchbury, John and Meijer, Erik and Sheard, Tim},
	year = {1996},
	pages = {68--114},
	file = {Jeuring and Jansson - 1996 - Polytypic programming.pdf:/home/mrl/.local/share/zotero/storage/SLC4G2IT/Jeuring and Jansson - 1996 - Polytypic programming.pdf:application/pdf},
}

@book{peyton_jones_haskell_2003,
	address = {Cambridge},
	title = {Haskell 98 language and libraries: the revised report},
	isbn = {0-521 826144},
	publisher = {Cambridge University Press},
	editor = {{Peyton Jones}, Simon},
	year = {2003},
}

@inproceedings{laufer_combining_1994,
	note = {event-place: Monterrey, Mexico},
	title = {Combining type classes and existential types},
	booktitle = {Proceedings of the {Latin} {American} {Informatic} {Conference} ({PANEL})},
	publisher = {ITESM-CEM},
	author = {Läufer, Konstantin},
	year = {1994},
	file = {Läufer - COMBINING TYPE CLASSES AND EXISTENTIAL TYPES.pdf:/home/mrl/.local/share/zotero/storage/KR4P9EHS/Läufer - COMBINING TYPE CLASSES AND EXISTENTIAL TYPES.pdf:application/pdf},
}

@techreport{hughes_restricted_1999,
	address = {Paris},
	title = {Restricted data types in {Haskell}},
	number = {UU-CS-1999-28},
	institution = {Department of Information and Computing Sciences, Utrecht University},
	author = {Hughes, John},
	year = {1999},
	pages = {16},
	file = {Hughes - 1999 - Restricted data types in Haskell.pdf:/home/mrl/.local/share/zotero/storage/7ZE2MYWE/Hughes - 1999 - Restricted data types in Haskell.pdf:application/pdf},
}

@article{najd_trees_2017,
	title = {Trees that {Grow}},
	volume = {23},
	abstract = {We study the notion of extensibility in functional data types, as a new approach to the problem of decorating abstract syntax trees with additional information. We observed the need for such extensibility while redesigning the data types representing Haskell abstract syntax inside Glasgow Haskell Compiler (GHC). Specifically, we describe a programming idiom that exploits type-level functions to allow a particular form of extensibility. The approach scales to support existentials and generalised algebraic data types, and we can use pattern synonyms to make it convenient in practice.},
	number = {1},
	journal = {Journal of Universal Computer Science},
	author = {Najd, Shayan and Peyton Jones, Simon},
	month = jan,
	year = {2017},
	pages = {42--62},
	file = {Najd and Jones - 2017 - Trees that Grow.pdf:/home/mrl/.local/share/zotero/storage/HYQFTWZP/Najd and Jones - 2017 - Trees that Grow.pdf:application/pdf},
}

@inproceedings{loh_open_2006,
	address = {New York, NY, USA},
	series = {{PPDP} '06},
	title = {Open {Data} {Types} and {Open} {Functions}},
	isbn = {1-59593-388-3},
	doi = {10.1145/1140335.1140352},
	abstract = {The problem of supporting the modular extensibility of both data and functions in one programming language at the same time is known as the expression problem. Functional languages traditionally make it easy to add new functions, but extending data (adding new data constructors) requires modifying existing code. We present a semantically and syntactically lightweight variant of open data types and open functions as a solution to the expression problem in the Haskell language. Constructors of open data types and equations of open functions may appear scattered throughout a program with several modules. The intended semantics is as follows: the program should behave as if the data types and functions were closed, defined in one place. The order of function equations is determined by best-fit pattern matching, where a specific pattern takes precedence over an unspecific one. We show that our solution is applicable to the expression problem, generic programming, and exceptions. We sketch two implementations: a direct implementation of the semantics, and a scheme based on mutually recursive modules that permits separate compilation},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} {International} {Conference} on {Principles} and {Practice} of {Declarative} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Löh, Andres and Hinze, Ralf},
	year = {2006},
	note = {event-place: Venice, Italy},
	keywords = {functional programming, Haskell, expression problem, extensible data types, extensible exceptions, extensible functions, generic programming, mutually recursive modules},
	pages = {133--144},
	file = {OpenDatatypes.pdf:/home/mrl/.local/share/zotero/storage/NEP9GZ9N/OpenDatatypes.pdf:application/pdf},
}

@inproceedings{hutton_fold_1998,
	address = {New York, NY, USA},
	series = {{ICFP} '98},
	title = {Fold and {Unfold} for {Program} {Semantics}},
	isbn = {1-58113-024-4},
	doi = {10.1145/289423.289457},
	abstract = {In this paper we explain how recursion operators can be used to structure and reason about program semantics within a functional language. In particular, we show how the recursion operator fold can be used to structure denotational semantics, how the dual recursion operator unfold can be used to structure operational semantics, and how algebraic properties of these operators can be used to reason about program semantics. The techniques are explained with the aid of two main examples, the first concerning arithmetic expressions, and the second concerning Milner's concurrent language CCS. The aim of the paper is to give functional programmers new insights into recursion operators, program semantics, and the relationships between them.},
	booktitle = {Proceedings of the {Third} {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Hutton, Graham},
	year = {1998},
	note = {event-place: Baltimore, MD, USA},
	pages = {280--288},
	file = {Hutton - 1998 - Fold and unfold for program semantics.pdf:/home/mrl/.local/share/zotero/storage/YEB9K2TP/Hutton - 1998 - Fold and unfold for program semantics.pdf:application/pdf},
}

@article{abadi_dynamic_1991,
	title = {Dynamic {Typing} in a {Statically} {Typed} {Language}},
	volume = {13},
	issn = {0164-0925},
	doi = {10.1145/103135.103138},
	abstract = {Statically typed programming languages allow earlier error checking, better enforcement of diciplined programming styles, and the generation of more efficient object code than languages where all type consistency checks are performed at run time. However, even in statically typed languages, there is often the need to deal with datawhose type cannot be determined at compile time. To handle such situations safely, we propose to add a type Dynamic whose values are pairs of a value v and a type tag T where v has the type denoted by T. Instances of Dynamic are built with an explicit tagging construct and inspected with a type safe typecase construct.This paper explores the syntax, operational semantics, and denotational semantics of a simple language that includes the type Dynamic. We give examples of how dynamically typed values can be used in programming. Then we discuss an operational semantics for our language and obtain a soundness theorem. We present two formulations of the denotational semantics of this language and relate them to the operational semantics. Finally, we consider the implications of polymorphism and some implementation issues.},
	number = {2},
	journal = {ACM Trans. Program. Lang. Syst.},
	author = {Abadi, Martín and Cardelli, Luca and Pierce, Benjamin and Plotkin, Gordon},
	month = apr,
	year = {1991},
	keywords = {theory},
	pages = {237--268},
	file = {Abadi et al. - 1991 - Dynamic typing in a statically typed language.pdf:/home/mrl/.local/share/zotero/storage/CJSBG6X7/Abadi et al. - 1991 - Dynamic typing in a statically typed language.pdf:application/pdf},
}

@inproceedings{svenningsson_combining_2013,
	address = {Berlin, Heidelberg},
	title = {Combining {Deep} and {Shallow} {Embedding} for {EDSL}},
	isbn = {978-3-642-40447-4},
	abstract = {When compiling embedded languages it is natural to use an abstract syntax tree to represent programs. This is known as a deep embedding and it is a rather cumbersome technique compared to other forms of embedding, typically leading to more code and being harder to extend. In shallow embeddings, language constructs are mapped directly to their semantics which yields more flexible and succinct implementations. But shallow embeddings are not well-suited for compiling embedded languages. We present a technique to combine deep and shallow embedding in the context of compiling embedded languages in order to provide the benefits of both techniques. In particular it helps keeping the deep embedding small and it makes extending the embedded language much easier. Our technique also has some unexpected but welcome knock-on effects. It provides fusion of functions to remove intermediate results for free without any additional effort. It also helps to give the embedded language a more natural programming interface.},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Svenningsson, Josef and Axelsson, Emil},
	editor = {Loidl, Hans-Wolfgang and Peña, Ricardo},
	doi = {10.1007/978-3-642-40447-4\_2},
	year = {2013},
	pages = {21--36},
	note = {event-place: St. Andrews, UK},
	file = {svenningsson2013combining.pdf:/home/mrl/.local/share/zotero/storage/NFBGZCZT/svenningsson2013combining.pdf:application/pdf},
}

@article{mitchell_abstract_1988,
	title = {Abstract {Types} {Have} {Existential} {Type}},
	volume = {10},
	issn = {0164-0925},
	doi = {10.1145/44501.45065},
	abstract = {Abstract data type declarations appear in typed programming languages like Ada, Alphard, CLU and ML. This form of declaration binds a list of identifiers to a type with associated operations, a composite “value” we call a data algebra. We use a second-order typed lambda calculus SOL to show how data algebras may be given types, passed as parameters, and returned as results of function calls. In the process, we discuss the semantics of abstract data type declarations and review a connection between typed programming languages and constructive logic.},
	number = {3},
	journal = {ACM Trans. Program. Lang. Syst.},
	author = {Mitchell, John C. and Plotkin, Gordon D.},
	month = jul,
	year = {1988},
	pages = {470--502},
	file = {Mitchell and Plotkin - 1988 - Abstract types have existential type.pdf:/home/mrl/.local/share/zotero/storage/QXDE5H7C/Mitchell and Plotkin - 1988 - Abstract types have existential type.pdf:application/pdf},
}

@inproceedings{yorgey_giving_2012,
	address = {New York, NY, USA},
	series = {{TLDI} '12},
	title = {Giving {Haskell} a {Promotion}},
	isbn = {978-1-4503-1120-5},
	doi = {10.1145/2103786.2103795},
	abstract = {Static type systems strive to be richly expressive while still being simple enough for programmers to use. We describe an experiment that enriches Haskell's kind system with two features promoted from its type system: data types and polymorphism. The new system has a very good power-to-weight ratio: it offers a significant improvement in expressiveness, but, by re-using concepts that programmers are already familiar with, the system is easy to understand and implement.},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} {Workshop} on {Types} in {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Yorgey, Brent A. and Weirich, Stephanie and Cretin, Julien and Peyton Jones, Simon and Vytiniotis, Dimitrios and Magalhães, José Pedro},
	year = {2012},
	note = {event-place: Philadelphia, PA, USA},
	keywords = {haskell, kinds, polymorphism, promotion},
	pages = {53--66},
	file = {Yorgey et al. - 2012 - Giving Haskell a Promotion.pdf:/home/mrl/.local/share/zotero/storage/7GTDGQ3I/Yorgey et al. - 2012 - Giving Haskell a Promotion.pdf:application/pdf},
}

@inproceedings{atkey_unembedding_2009,
	address = {New York, NY, USA},
	series = {Haskell '09},
	title = {Unembedding {Domain}-{Specific} {Languages}},
	isbn = {978-1-60558-508-6},
	doi = {10.1145/1596638.1596644},
	abstract = {Higher-order abstract syntax provides a convenient way of embedding domain-specific languages, but is awkward to analyse and manipulate directly. We explore the boundaries of higher-order abstract syntax. Our key tool is the unembedding of embedded terms as de Bruijn terms, enabling intensional analysis. As part of our solution we present techniques for separating the definition of an embedded program from its interpretation, giving modular extensions of the embedded language, and different ways to encode the types of the embedded language.},
	booktitle = {Proceedings of the 2nd {ACM} {SIGPLAN} {Symposium} on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Atkey, Robert and Lindley, Sam and Yallop, Jeremy},
	year = {2009},
	note = {event-place: Edinburgh, Scotland},
	keywords = {domain-specific languages, higher-order abstract syntax, type classes, unembedding},
	pages = {37--48},
	file = {Atkey et al. - 2009 - Unembedding Domain-Specific Languages.pdf:/home/mrl/.local/share/zotero/storage/GVFRIDUG/Atkey et al. - 2009 - Unembedding Domain-Specific Languages.pdf:application/pdf},
}

@inproceedings{krishnamurthi_synthesizing_1998,
	address = {Berlin, Heidelberg},
	title = {Synthesizing object-oriented and functional design to promote re-use},
	isbn = {978-3-540-69064-1},
	abstract = {Many problems require recursively specified types of data and a collection of tools that operate on those data. Over time, these problems evolve so that the programmer must extend the toolkit or extend the types and adjust the existing tools accordingly. Ideally, this should be done without modifying existing code. Unfortunately, the prevailing program design strategies do not support both forms of extensibility: functional programming accommodates the addition of tools, while object-oriented programming supports either adding new tools or extending the data set, but not both. In this paper, we present a composite design pattern that synthesizes the best of both approaches and in the process resolves the tension between the two design strategies. We also show how this protocol suggests a new set of linguistic facilities for languages that support class systems.},
	booktitle = {{ECOOP}'98 — {Object}-{Oriented} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Krishnamurthi, Shriram and Felleisen, Matthias and Friedman, Daniel P.},
	editor = {Jul, Eric},
	year = {1998},
	pages = {91--113},
	note = {event-place: Brussels, Belgium},
	file = {Krishnamurthi et al. - 1998 - Synthesizing object-oriented and functional design.pdf:/home/mrl/.local/share/zotero/storage/AMMULPPT/Krishnamurthi et al. - 1998 - Synthesizing object-oriented and functional design.pdf:application/pdf},
}

@incollection{gibbons_functional_2015,
	address = {Cham},
	title = {Functional {Programming} for {Domain}-{Specific} {Languages}},
	isbn = {978-3-319-15940-9},
	abstract = {Domain-specific languages are a popular application area for functional programming; and conversely, functional programming is a popular implementation vehicle for domain-specific languages—at least, for embedded ones. Why is this? The appeal of embedded domain-specific languages is greatly enhanced by the presence of convenient lightweight tools for defining, implementing, and optimising new languages; such tools represent one of functional programming's strengths. In these lectures we discuss functional programming techniques for embedded domain-specific languages; we focus especially on algebraic datatypes and higher-order functions, and their influence on deep and shallow embeddings.},
	booktitle = {Central {European} {Functional} {Programming} {School}: 5th {Summer} {School}, {CEFP} 2013, {Cluj}-{Napoca}, {Romania}, {July} 8-20, 2013, {Revised} {Selected} {Papers}},
	publisher = {Springer International Publishing},
	author = {Gibbons, Jeremy},
	editor = {Zsók, Viktória and Horváth, Zoltán and Csató, Lehel},
	year = {2015},
	doi = {10.1007/978-3-319-15940-9\_1},
	pages = {1--28},
	file = {Gibbons - 2015 - Functional Programming for Domain-Specific Languag.pdf:/home/mrl/.local/share/zotero/storage/ARUBLFU6/Gibbons - 2015 - Functional Programming for Domain-Specific Languag.pdf:application/pdf},
}

@inproceedings{baars_typing_2002,
	author = {Baars, Arthur I. and Swierstra, S. Doaitse},
	title = {Typing Dynamic Typing},
	year = {2002},
	isbn = {1581134878},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	doi = {10.1145/581478.581494},
	abstract = {Even when programming in a statically typed language we every now and then encounter statically untypable values; such values result from interpreting values or from communicating with the outside world. To cope with this problem most languages include some form of dynamic types. It may be that the core language has been explicitly extended with such a type, or that one is allowed to live dangerously by using functions like unsafeCoerce. We show how, by a careful use of existentially and universally quantified types, one may achievem the same effect, without extending the language with new or unsafe features. The techniques explained are universally applicable, provided the core language is expressive enough; this is the case for the common implementations of Haskell. The techniques are used in the description of a type checking compiler that, starting from an expression term, constructs a typed function representing the semantics of that expression. In this function the overhead associated with the type checking is only once being paid for; in this sense we have thus achieved static type checking.},
	booktitle = {Proceedings of the Seventh ACM SIGPLAN International Conference on Functional Programming},
	pages = {157–166},
	numpages = {10},
	keywords = {dynamic typing, coercions, typed interpreters, type equality, Leibnitz' rule, Haskell, static typing, quantified types},
	location = {Pittsburgh, PA, USA},
	series = {ICFP '02}
}

@article{swierstra_data_2008,
	title = {Data types à la carte},
	volume = {18},
	number = {4},
	journal = {Journal of functional programming},
	author = {Swierstra, Wouter},
	year = {2008},
	pages = {423--436},
	doi = {10.1017/S0956796808006758},
	file = {swierstra2008.pdf:/home/mrl/.local/share/zotero/storage/BEQKBXWP/swierstra2008.pdf:application/pdf},
}

@inproceedings{cheney_lightweight_2002,
	title = {A lightweight implementation of generics and dynamics},
	url = {http://dl.acm.org/citation.cfm?id=581698},
	doi = {10.1145/581690.581698},
	urldate = {2017-05-15},
	booktitle = {Proceedings of the 2002 {ACM} {SIGPLAN} workshop on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Cheney, James and Hinze, Ralf},
	year = {2002},
	note = {event-place: Pittsburgh, PA, USA},
	keywords = {dynamic typing, generic programming, type representations},
	pages = {90--104},
	file = {Cheney and Hinze - 2002 - A lightweight implementation of generics and dynam.pdf:/home/mrl/.local/share/zotero/storage/FZ6EGJRJ/Cheney and Hinze - 2002 - A lightweight implementation of generics and dynam.pdf:application/pdf;HW02.pdf:/home/mrl/.local/share/zotero/storage/A8Z49NK6/HW02.pdf:application/pdf},
}

@book{peyton_jones_implementation_1987,
	title = {The {Implementation} of {Functional} {Programming} {Languages}},
	url = {https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/},
	abstract = {My 1987 book is now out of print, but it is available here in its entirety in PDF form, in one of two formats: single-page portrait double-page landscape Both are fully searchable, thanks to OCR and Norman Ramsey. Errata Section 5.2.4, p87. We need an extra rule match us [] E = E This accounts for the possibility that in the constructor rule (Section 5.2.4) there may be some non-nullary constructors for which there are no equations. P168, line 2, "VAR" should be "TVAR".},
	publisher = {Prentice Hall},
	author = {Peyton Jones, Simon},
	month = jan,
	year = {1987},
	file = {Peyton Jones - 1987 - The Implementation of Functional Programming Langu.pdf:/home/mrl/.local/share/zotero/storage/9RIR6KGD/Peyton Jones - 1987 - The Implementation of Functional Programming Langu.pdf:application/pdf},
}

@incollection{kiselyov_typed_2012,
	address = {Berlin, Heidelberg},
	title = {Typed {Tagless} {Final} {Interpreters}},
	isbn = {978-3-642-32202-0},
	abstract = {The so-called `typed tagless final' approach of [6] has collected and polished a number of techniques for representing typed higher-order languages in a typed metalanguage, along with type-preserving interpretation, compilation and partial evaluation. The approach is an alternative to the traditional, or `initial' encoding of an object language as a (generalized) algebraic data type. Both approaches permit multiple interpretations of an expression, to evaluate it, pretty-print, etc. The final encoding represents all and only typed object terms without resorting to generalized algebraic data types, dependent or other fancy types. The final encoding lets us add new language forms and interpretations without breaking the existing terms and interpreters.},
	booktitle = {Generic and {Indexed} {Programming}: {International} {Spring} {School}, {SSGIP} 2010, {Oxford}, {UK}, {March} 22-26, 2010, {Revised} {Lectures}},
	publisher = {Springer Berlin Heidelberg},
	author = {Kiselyov, Oleg},
	editor = {Gibbons, Jeremy},
	year = {2012},
	doi = {10.1007/978-3-642-32202-0\_3},
	pages = {130--174},
	file = {Kiselyov - 2012 - Typed Tagless Final Interpreters.pdf:/home/mrl/.local/share/zotero/storage/9NBYZLRP/Kiselyov - 2012 - Typed Tagless Final Interpreters.pdf:application/pdf},
}

@article{laufer_type_1996,
	title = {Type classes with existential types},
	volume = {6},
	doi = {10.1017/S0956796800001817},
	number = {3},
	journal = {Journal of Functional Programming},
	author = {Läufer, Konstantin},
	year = {1996},
	pages = {485--518},
	file = {Läufer - 1996 - Type classes with existential types.pdf:/home/mrl/.local/share/zotero/storage/FG73PZJE/Läufer - 1996 - Type classes with existential types.pdf:application/pdf},
}

@incollection{hinze_fun_2003,
	address = {Palgrave},
	series = {Cornerstones of {Computing}},
	title = {Fun {With} {Phantom} {Types}},
	isbn = {978-0-333-99285-2},
	booktitle = {The {Fun} of {Programming}},
	publisher = {Bloomsbury Publishing},
	author = {Hinze, Ralf},
	editor = {Gibbons, Jeremy and de Moor, Oege},
	year = {2003},
	pages = {245--262},
}

@inproceedings{boulton_experience_1992,
	address = {Amsterdam, NL},
	title = {Experience with embedding hardware description languages in {HOL}},
	volume = {10},
	isbn = {0-444-89686-4},
	abstract = {The semantics of hardware description languages can be represented in higher order logic. This provides a formal de nition that is suitable for machine processing. Experiments are in progress at Cambridge to see whether this method can be the basis of practical tools based on the HOL theorem-proving assistant. Three languages are being investigated: ELLA, Silage and VHDL. The approaches taken for these languages are compared and current progress on building semantically-based theorem-proving tools is discussed.},
	language = {en},
	booktitle = {{IFIP} {TC10}/{WG}},
	publisher = {Elsevier},
	author = {Boulton, Richard and Gordon, Andrew and Gordon, Mike and Harrison, John and Herbert, John and Tassel, John Van},
	editor = {Stavridou, Victoria and Melham, Thomas F. and Boute, Raymond T.},
	year = {1992},
	pages = {129--156},
	file = {Boulton et al. - Experience with embedding hardware description lan.pdf:/home/mrl/.local/share/zotero/storage/USAAA6WM/Boulton et al. - Experience with embedding hardware description lan.pdf:application/pdf},
	note = {event-place: Nijmegen, NL}
}

@inproceedings{gibbons_folding_2014,
	address = {New York, NY, USA},
	series = {{ICFP} '14},
	title = {Folding {Domain}-{Specific} {Languages}: {Deep} and {Shallow} {Embeddings} ({Functional} {Pearl})},
	isbn = {978-1-4503-2873-9},
	doi = {10.1145/2628136.2628138},
	abstract = {A domain-specific language can be implemented by embedding within a general-purpose host language. This embedding may be deep or shallow, depending on whether terms in the language construct syntactic or semantic representations. The deep and shallow styles are closely related, and intimately connected to folds; in this paper, we explore that connection.},
	booktitle = {Proceedings of the 19th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Gibbons, Jeremy and Wu, Nicolas},
	year = {2014},
	note = {event-place: Gothenburg, Sweden},
	keywords = {domain-specific languages, deep and shallow embedding, folds},
	pages = {339--347},
	file = {Gibbons and Wu - 2014 - Folding Domain-Specific Languages Deep and Shallo.pdf:/home/mrl/.local/share/zotero/storage/6WNWSLFJ/Gibbons and Wu - 2014 - Folding Domain-Specific Languages Deep and Shallo.pdf:application/pdf},
}

@inproceedings{oliveira_typecase_2005,
	address = {New York, NY, USA},
	series = {Haskell '05},
	title = {{TypeCase}: {A} {Design} {Pattern} for {Type}-{Indexed} {Functions}},
	isbn = {1-59593-071-X},
	doi = {10.1145/1088348.1088358},
	abstract = {A type-indexed function is a function that is defined for each member of some family of types. Haskell's type class mechanism provides collections of open type-indexed functions, in which the indexing family can be extended by defining a new type class instance but the collection of functions is fixed. The purpose of this paper is to present TypeCase: a design pattern that allows the definition of closed type-indexed functions, in which the index family is fixed but the collection of functions is extensible. It is inspired by Cheney and Hinze's work on lightweight approaches to generic programming. We generalise their techniques as a design pattern. Furthermore, we show that type-indexed functions with type-indexed types, and consequently generic functions with generic types, can also be encoded in a lightweight manner, thereby overcoming one of the main limitations of the lightweight approaches.},
	booktitle = {Proceedings of the 2005 {ACM} {SIGPLAN} {Workshop} on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Oliveira, Bruno C. d. S. and Gibbons, Jeremy},
	year = {2005},
	note = {event-place: Tallinn, Estonia},
	keywords = {generic programming, type classes, type-indexed functions},
	pages = {98--109},
	file = {Oliveira and Gibbons - 2005 - TypeCase A Design Pattern for Type-Indexed Functi.pdf:/home/mrl/.local/share/zotero/storage/RBKEZKHN/Oliveira and Gibbons - 2005 - TypeCase A Design Pattern for Type-Indexed Functi.pdf:application/pdf},
}

@inproceedings{odersky_putting_1996,
	address = {New York, NY, USA},
	series = {{POPL} '96},
	title = {Putting {Type} {Annotations} to {Work}},
	isbn = {0-89791-769-3},
	doi = {10.1145/237721.237729},
	abstract = {We study an extension of the Hindley/Milner system with explicit type scheme annotations and type declarations. The system can express polymorphic function arguments, user-defined data types with abstract components, and structure types with polymorphic fields. More generally, all programs of the polymorphic lambda calculus can be encoded by a translation between typing derivations. We show that type reconstruction in this system can be reduced to the decidable problem of first-order unification under a mixed prefix.},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Odersky, Martin and Läufer, Konstantin},
	year = {1996},
	note = {event-place: St. Petersburg Beach, FL, USA},
	pages = {54--67},
	file = {Odersky and Läufer - 1996 - Putting Type Annotations to Work.pdf:/home/mrl/.local/share/zotero/storage/WC37TU5H/Odersky and Läufer - 1996 - Putting Type Annotations to Work.pdf:application/pdf},
}

@article{carette_finally_2009,
	title = {Finally tagless, partially evaluated: {Tagless} staged interpreters for simpler typed languages},
	volume = {19},
	doi = {10.1017/S0956796809007205},
	number = {5},
	journal = {Journal of Functional Programming},
	author = {Carette, Jacques and Kiselyov, Oleg and Shan, Chung-Chieh},
	year = {2009},
	pages = {509--543},
	file = {CARETTE et al. - 2009 - Finally tagless, partially evaluated Tagless stag.pdf:/home/mrl/.local/share/zotero/storage/T8C8VMHP/CARETTE et al. - 2009 - Finally tagless, partially evaluated Tagless stag.pdf:application/pdf},
}

@techreport{cheney_first-class_2003,
	title = {First-class phantom types},
	url = {https://ecommons.cornell.edu/handle/1813/5614},
	number = {TR2003-1901},
	urldate = {2017-05-15},
	institution = {Cornell University},
	author = {Cheney, James and Hinze, Ralf},
	year = {2003},
	file = {Cheney and Hinze - 2003 - First-class phantom types.pdf:/home/mrl/.local/share/zotero/storage/IBKGCFG2/Cheney and Hinze - 2003 - First-class phantom types.pdf:application/pdf},
}

@misc{wadler_expression_1998,
	title = {The expression problem},
	url = {https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt},
	author = {Wadler, Philip},
	note = {e-mail message, accessed on: 2021-02-24},
	year = {1998-11-12},
	file = {expression.txt:/home/mrl/.local/share/zotero/storage/N9SAT6EN/expression.txt:text/plain}
}
